# Simulink水动力学阻尼模块分析

## 1. 模块功能概述

### 提问

<div align="center">

![Damping Module](https://cdn.nlark.com/yuque/0/2025/png/2408029/1752651567402-b4a84a94-1767-40b7-8a05-80128043d31d.png)

</div>

你前面提到——[ω₃ ω₄ ω₅]：竖向、横摇、纵倾三自由度的固有频率

这个固有频率（Natural frequencies）被用在了图中这个Hydrodynamics中的Damping(Hydrodynamics)这个模块里面。介绍一下这个模块的功能/固有频率的作用和整个模块起作用的机理。

### 回答

下面这个"Damping"子模块的作用，就是根据当前各自由度的速度（u,v,w,p,q,r），计算出线性粘滞阻尼力/力矩τ_damp，并送入六自由度运动方程。它内部实际上是在构造一个对角的阻尼系数矩阵D，使得：

$$\tau_\text{damp} = -D \begin{bmatrix}u\\v\\w\\p\\q\\r\end{bmatrix} \quad\text{其中}\quad D=\text{diag}([X_u, Y_v, Z_w, K_p, M_q, N_r])$$

下面逐路径解释，各个阻尼系数是如何借助固有频率 ω₃,ω₄,ω₅（heave/roll/pitch）以及其他参数算出来的。

---

### 1.1 垂荡、横摇、纵倾方向的线性阻尼：Zw、Kp、Mq

**输入：**

- **Inertials**：对应三个模态的等效惯性（heave 用的是质量 M₃₃；roll 用的是转动惯量 Iₓₓ；pitch 用的是 Iᵧᵧ）。
- **Natural Frequencies**：对应三个模态的固有角频率 ω₃ (heave)、ω₄ (roll)、ω₅ (pitch)。
- **Damping ratios**：在模块里硬编码为 ζ_heave=0.3、ζ_roll=0.2、ζ_pitch=0.4。

**计算机理：**

任何线性二阶系统（惯性 M、刚度 G）自然频率满足：

$$\omega = \sqrt{\frac{G}{M}}$$

若我们希望阻尼比 ζ（通常小于1），则临界阻尼系数应取：

$$C_\text{crit} = 2 M \omega$$

真实阻尼系数就是：

$$C = 2 \zeta M \omega$$

因此模块里先用一个 MUX 把对应的 M 和 ω 串联，再过一个 "×(–2)"（负号表示阻尼力与速度反向），得到临界阻尼，再分别乘以 ζ_heave、ζ_roll、ζ_pitch，最终输出：

$$\begin{cases}
Z_w = -2\zeta_\text{heave} M_{33} \omega_3\\
K_p = -2\zeta_\text{roll} I_{xx} \omega_4\\
M_q = -2\zeta_\text{pitch} I_{yy} \omega_5
\end{cases}$$

---

### 1.2 侧荡方向的非线性"横流"阻尼：Yv

**输入：**

- **Relative Velocity** 中的纵向速度 u（取绝对值）。

**计算公式：**

模块里用一个"|u|×10 + 1"的形式，再乘以–1，得到对v的阻尼系数：

$$Y_v = -(1 + 10|u|)$$

这是一种经验式的横流黏滞阻尼，随前进速度加大而非线性增大。

---

### 1.3 纵向（冲）方向的阻尼：Xu

**输入：**

- **Gravity**（g）
- 以及一个经验常数"–24.4/U_max"的增益块

**计算：**

把 g 乘以该增益，得到 Xu（与 u 同向的线性阻尼系数）：

$$X_u = -\frac{24.4}{U_{\max}} g$$

这也是工业上常见的经验区间。

---

### 1.4 偏航方向的阻尼：Nr

**输入：**

- **Inertials** 中的偏航转动惯量 I_zz
- **T_yaw**（偏航自然周期）

**计算：**

简化为用周期倒数来近似阻尼：

$$N_r = -\frac{I_{zz}}{T_{\text{yaw}}}$$

（负号保证阻尼力矩反向于角速度 r。）

---

### 1.5 总线输出与作用机理

- 上述六个系数分别汇入一个多路复用器，形成 $X_u, Y_v, Z_w, K_p, M_q, N_r$。
- 最后与当前速度向量 $[u,v,w,p,q,r]$ 相乘，即得到阻尼力和阻尼力矩 $\tau_\text{damp}$。
- 阻尼模块模拟了水体对各自由度运动的逐项耗散，配合刚度（静水恢复力）和外部激励，共同决定船体的动态响应。

---

**总结：**

这个 Damping 模块利用 **固有频率**（ω₃,ω₄,ω₅）结合 **等效惯性**，按 $C=2\zeta M\omega$ 原理给出 heave/roll/pitch 的线性阻尼；用经验公式给出 surge、sway、yaw 的阻尼系数；最后形成对角阻尼矩阵，直接与速度相乘，完成粘滞耗散力/力矩的计算。

---

## 2. 阻尼矩阵对角化条件

### 提问

<div align="center">

![Damping Matrix](https://cdn.nlark.com/yuque/0/2025/png/2408029/1755138152052-4673db31-3f34-453a-a3cb-81454f0b2734.png)

</div>

什么时候可以转化为对角阵？

### 回答

像图中的 $D_{\text{lin}}$ 这种线性阻尼矩阵，能否转化为对角阵，取决于**是否存在自由度间的水动力耦合**。

#### 2.1 可以转化为对角阵的条件

- 船体形状、对称性较高（比如纵向、横向、垂向三个平移方向之间没有显著耦合）。
- 选取的船体坐标系刚好是**水动力中心**或**对称中心**，这样水动力作用不会引起交叉耦合力矩。
- PMM 试验或 CFD 得出的交叉阻尼系数（如 $Y_r$、$N_v$、$Z_q$、$M_w$ 等）非常小，可以近似为零。

在这种情况下，$D_{\text{lin}}$ 近似为：

$$D_{\text{lin}} \approx \text{diag}(X_u, Y_v, Z_w, K_p, M_q, N_r)$$

每个自由度的阻尼只与本自由度速度有关。

#### 2.2 不能转化为对角阵的情况

- 船体非对称（如单侧舷装有推进器、舵、侧推等）。
- 流体绕射或兴波效应导致不同自由度间显著耦合。
- 小型船舶在大航速下，横荡与艏摇、垂荡与纵摇之间往往存在明显的阻尼耦合。

#### 2.3 工程处理建议

- **初步建模/控制器设计**：可以将小的耦合项近似为零，把 $D_{\text{lin}}$ 对角化，简化计算。
- **高精度操纵性仿真**：应保留 PMM/CFD 测得的交叉阻尼项，保持矩阵非对角形式。

---

## 3. 关键参数解释

### 提问

<div align="center">

![Parameters](https://cdn.nlark.com/yuque/0/2025/png/2408029/1755139188737-d9fdfbeb-1363-457a-b028-86e2a8f5cbd1.png)

</div>

其中的M₃₃和ω₃分别代表什么？

### 回答

根据图片中的内容和船舶动力学理论：

**M₃₃** 代表：

- **第3个自由度（Heave）的等效质量**
- 在6×6质量矩阵中第3行第3列的元素
- 即垂荡方向的惯性参数（质量）

**ω₃** 代表：

- **第3个自由度（Heave）的固有频率**
- 即垂荡模态的自然振动频率

#### 背景解释

在船舶六自由度系统中，各自由度按顺序编号：

1. Surge（纵荡）
2. Sway（横荡）
3. **Heave（垂荡）** ← 第3个自由度
4. Roll（横摇）
5. Pitch（纵摇）
6. Yaw（艏摇）

因此：

- M₃₃ 是质量矩阵中垂荡方向的对角元素，表示船舶在垂直方向运动时的惯性
- ω₃ 是垂荡的固有频率，由 $\omega = \sqrt{G/M}$ 计算得出，其中G是恢复力系数

在阻尼计算公式 $Z_w = -2\zeta_{\text{heave}} M_{33} \omega_3$ 中：

- $Z_w$ 是垂荡方向的线性阻尼系数
- $\zeta_{\text{heave}} = 0.3$ 是垂荡的阻尼比
- $M_{33}$ 和 $\omega_3$ 共同决定了垂荡运动的动力学特性

---

## 4. Yaw偏航阻尼详细分析

### 提问

<div align="center">

![Yaw Damping](https://cdn.nlark.com/yuque/0/2025/png/2408029/1766029306989-effee72d-d260-4bf1-9da9-6910e96bab35.png)

</div>

帮我分析一下这个里面Yaw部分阻尼力矩计算的表达式和对应的Simulink接线机理。

### 回答

你这张图红框里其实是在**构造偏航阻尼矩的系数 ($N_r$)**，并且让它随**纵向相对速度 ($|u|$)** 增大而增大；最后在右侧统一把各阻尼系数 ($[X_u,Y_v,Z_w,K_p,M_q,N_r]$) 与相对速度向量 ($\nu_r=[u,v,w,p,q,r]^T$) 相乘，得到阻尼力/力矩 ($\tau_{\text{damp}}$)。

下面把 **Yaw（偏航）部分**的表达式和"接线机理"拆开讲清楚。

---

### 4.1 红框里最终要算的是什么？

红框右侧输出进那根竖向汇总总线（标了 Xu、Yv、Zw、Kp、Mq、**Nr**）的量，是 **偏航阻尼系数 ($N_r$)**（用于 yaw rate (r) 的阻尼矩）。

随后在最右边的大乘法块里做：

$$\tau_{\text{damp}} = -D \cdot \nu_r$$

因此 **偏航阻尼力矩分量**就是：

$$N_{\text{damp}} = N_r \cdot r$$

其中 $N_r$ 在红框里被做成了"随 $|u|$ 增大而增大"的形式。

---

### 4.2 红框里 Yaw 阻尼系数 ($N_r$) 的表达式

从接线图看，红框里 $N_r$ 是这样构造的（结构非常典型）：

#### (A) 基础偏航阻尼系数（由惯量 + 时间常数给出）

上支路：从 **Inertials** 里取出某个惯量项（基本可以判定是 $I_{zz}$），再结合一个常数 **T_yaw**（偏航时间常数/期望时间尺度），形成一个基础系数：

$$N_{r0} = -\frac{I_{zz}}{T_{\text{yaw}}}$$

对应接线：

- `U/Y` 选择器：从 `Inertials` 里"取出某个量"（多半是 $I_{zz}$）
- 旁边的 `T_yaw` 常数：提供 $T_{\text{yaw}}$
- 中间那个带 "x / +" 图标的块：通常是 **乘除组合（Product/Divide）** 的一种配置（你这里的意图基本就是做 $I_{zz}/T_{yaw}$ 或类似组合）
- 后面的 `-1` 增益：把符号变为负号（形成阻尼方向）

> 你这条线上标了 "Nr"，说明这条线确实是在形成 yaw 的阻尼系数，而不是直接形成力矩。

#### (B) 速度相关的放大因子（随 $|u|$ 增大）

下支路：从 **Relative Velocity** 里取出纵向相对速度 $u$，取绝对值，再做线性放大并加 1：

$$f(u) = 1 + 10|u|$$

对应接线：

- `U/Y`：从 Relative Velocity 里选出 $u$ 分量
- `|u|`：绝对值
- `10`：增益
- `+` 与常数 `1`：得到 $1+10|u|$

#### (C) 合成最终的 $N_r$

最后用右侧竖着的乘法块把两条支路相乘：

$$N_r = N_{r0} \cdot f(u) = \left(-\frac{I_{zz}}{T_{\text{yaw}}}\right)\left(1+10|u|\right)$$

于是偏航阻尼力矩就是：

$$N_{\text{damp}} = N_r \cdot r = \left(-\frac{I_{zz}}{T_{\text{yaw}}}\right)\left(1+10|u|\right) r$$

---

## 5. 偏航阻尼系数的物理直觉讨论

### 提问

<div align="center">

![Yaw Damping Formula](https://cdn.nlark.com/yuque/0/2025/png/2408029/1766109113772-92e03fb8-15ff-4ffa-8d20-943a04588227.png)

</div>

偏航阻尼系数使用这个，速度相关的放大因子（随 $|u|$ 增大），有点违背我的常识，我以为纵向速度越大，在偏航时越容易偏航，轻轻一转弯就有可能偏航，就和开赛车似的，现在这个公式违背我常识了，你怎么看？

### 回答

你这个"直觉"**非常对，而且是更接近真实船舶/车辆物理的那一侧**。关键在于：**你现在这个公式把两种完全不同的物理现象混在了一起**，所以才会让你产生"违背常识"的感觉——而你感觉到的不适，本身就是一个**非常可靠的工程直觉**。

#### 5.1 先把"常识"说清楚：你脑子里的直觉对应的是哪种物理？

你现在的直觉是：

> 纵向速度越大 → 稍微给一点偏航输入 → 更容易发生偏航 / 甩尾

这在物理上对应的是：

- 稳定性下降（yaw stability ↓）
- 系统对偏航扰动更敏感
- 偏航角速度更容易被"激发"出来

⚠️ 注意：
- 👉 这说的是 "偏航更容易发生"
- 👉 不是"偏航阻尼更大"

**这是两个完全不同的概念。**

#### 5.2 你现在用的公式，描述的是什么物理？

你现在用的是：

$$N_r = \frac{I_{zz}}{T_{yaw}} (1 + 10|u|)$$

并最终形成阻尼矩：

$$N_{\text{damp}} = - N_r \cdot r$$

这在物理上表达的是：

> "纵向速度越大，偏航阻尼越强，系统越不容易持续转动"

也就是说：

- 偏航角速度 $r$ 一起来
- 阻尼矩立刻被 $(1+10|u|)$ 放大
- 系统被"狠狠拉回去"

👉 这描述的是一种 **高速时偏航被强力抑制的船**
👉 更像是"高速巡航稳定平台"，而不是"赛车/快艇/轻快无人船"

#### 5.3 为什么你的常识是对的，而这个公式在"仿真建模"里却经常出现？

**真正的矛盾点在这里**

你现在的疑惑不是"谁对谁错"，而是：
> "为什么速度越大，模型却让偏航更难？"

答案是：
> 因为你现在用的是"人为稳定化模型"，而不是"自然动力学模型"

**工程上有两种完全不同的建模哲学（这是关键）**

**🟦 A 类：自然动力学模型（更符合你的直觉）**

- 高速 → 稳定性下降
- 小扰动 → 大响应
- 偏航"更容易被激发"

常见于：
- 赛车
- 快艇
- 高速无人艇
- 真实船舶在无控制介入时

对应建模特征：
- $N_r$ 不随 $u$ 增大，甚至减小
- 不额外"帮系统稳定"
- 靠真实流体耦合决定稳定性

👉 **你的直觉就在这一类**

**🟥 B 类：人为稳定化模型（你现在用的）**

- 高速 → 人为增强阻尼
- 偏航一出现就"被压死"
- 保证数值稳定、轨迹好看、控制器好调

常见于：
- Simulink 官方示例
- 教学模型
- 工程早期"保守模型"
- 强控制闭环前的 plant 简化模型

👉 这种模型的潜台词是：
> "我不关心真实是否容易甩尾，我只要它别炸、别乱转"

#### 5.4 用一句话点破你现在的不适感

你现在的感觉其实是：
> "这个模型在高速时，替我偷偷加了一个'电子稳定系统'，而我本来想要的是'裸车'。"

而你是对的，因为：
- 你在做 **无人船真实物理仿真**
- 不是在做"演示级稳定模型"

#### 5.5 到底该不该用 $(1+10|u|)$ 这种放大因子？

**✔️ 什么时候"可以用"？**

- 你现在**主要目标是数值稳定**
- 你还没调完推进器 / 耦合项
- 你只想"先跑起来不炸"
- 这是一个 **过渡模型**

**❌ 什么时候"不应该用"？**

- 你在验证**真实转弯半径**
- 你在研究**差速推进真实行为**
- 你在评估**高速偏航风险**
- 你在做**控制算法鲁棒性分析**

👉 从你现在的问题来看：
**你已经进入"不该再用它"的阶段了。**

#### 5.6 更符合你常识的替代思路

**✅ 更合理的做法之一（推荐）**

**把"速度相关性"放在"激励侧"，而不是"阻尼侧"**

也就是说：
- 不去让 $N_r$ 随 $|u|$ 增大
- 而是承认：同样的推进器差速，在高速下产生更强偏航响应

例如：
- 推进器力矩 ∝ $u$
- 或侧滑耦合项增强
- 而不是"阻尼变大"

**✅ 一个更物理直观的 yaw 阻尼形式**

如果你一定要速度相关，可以用：

$$N_r = N_{r0} + N_{r2} |r|$$

或者（非常常见）：

$$N_{\text{damp}} = - N_{r0} r - N_{r2} |r| r$$

👉 **阻尼随"转得多快"增强，而不是随"走得多快"增强**

这才符合你"赛车感"的直觉。

---

## 6. Divide/Product 模块和 Selector 模块解析

### 提问

<div align="center">

![Divide Module](https://cdn.nlark.com/yuque/0/2025/png/2408029/1766109010393-5d690c4f-55ca-47b9-98d0-ef6beeb95970.png)

</div>

解释这两个模块的作用。这个Divide模块你仔细看，输入数目是：`*/` 是不是还是有除法？

### 回答

#### 6.1 `Divide / Product` 模块

这是一个 **Product（乘法）模块**，当前设置为：
> 乘法：按元素 (.*)

也就是说：
- 不会做矩阵乘
- 不会自动倒数
- 对输入向量/标量是 **逐元素相乘**

你看得非常细，这里确实还是"有除法"的——关键不在于下面那个"乘法：按元素(.)"下拉框，而在于你勾选的 **"输入数目：`*/`"** 这个配置。

**`输入数目：*/` 在 Product（Divide）模块里是什么意思？**

在 Simulink 的 Product 模块里，"输入数目"这一栏决定了**每个输入端口是做乘还是做除**：

| 配置 | 含义 |
|------|------|
| `**` | 两路输入都在乘号侧 → $y = u_1 \cdot u_2$ |
| `*/` | 第一路在乘号侧，第二路在除号侧 → $y = \frac{u_1}{u_2}$ |
| `/**` | 第一路在除号侧（不常用） |
| `***/` | 前三路乘，最后一路除 → $y = u_1 u_2 u_3 / u_4$ |

所以你这个模块的实际运算是：

$$\boxed{y = u_1 \;./\; u_2}$$

也就是"逐元素除法"。

**为什么下拉框写着"按元素(.*)"也没矛盾？**

不矛盾。
- 下拉框"按元素"决定的是：如果输入是向量/矩阵，是做 **逐元素** 还是 **矩阵乘/除**
- "输入数目：`*/`"决定的是：端口之间是 **乘还是除**

因此你这个模块的完整含义是：

$$\boxed{y = u_1 \;./\; u_2}$$

逐元素除法，完全没问题。

**放回到你 Yaw 阻尼那条链路，它在算什么？**

如果这个 Product 模块在你那条线上是：
- 上端口：Selector 取出来的 $I_{zz}$
- 下端口：常数 $T_{yaw}$

那么它算的就是你想要的：

$$\boxed{\frac{I_{zz}}{T_{yaw}}}$$

后面再乘 $(1+10|u|)$，再乘 $r$，再加负号，形成阻尼矩。

#### 6.2 `Selector` 模块

这是一个 **向量/矩阵选择器**，当前配置是：
- 输入端口数：2
- 索引方式：索引向量（对话框）
- 两个输入端口的索引都选的是：6

结合你上下文，这个 Selector：
- 输入 1：Relative Velocity
- 输入 2：Relative Velocity（或同维度状态向量）

而索引都选 6，意味着：

$$\text{输出} = \nu_r(6)$$

也就是：

$$\boxed{r = \text{yaw rate}}$$

📌 换句话说：**这个 Selector 是在"精准地取偏航角速度 r"**

---

## 7. Add/Sum 模块与 Selector 输出维度分析

### 提问

<div align="center">

![Add Module](https://cdn.nlark.com/yuque/0/2025/png/2408029/1766109162622-e539cc70-128e-4328-a16a-0736d41dad12.png)

</div>

解释一下这个模块的作用。另外，Selector选择输入2个端口，都选择6号，但是只输出一个6号对么？那另一个什么时候起作用？

### 回答

#### 7.1 `Add2 / Sum` 模块（符号列表：`++`）

这个 `Add2` 模块的配置是：
- 符号列表：**++**
- 输入端口数：2

因此它做的事情只有一件：

$$y = u_1 + u_2$$

没有别的逻辑：
- ❌ 不归一化
- ❌ 不限幅
- ❌ 不判断符号
- ❌ 不做矩阵乘

就是逐元素相加（如果是向量）或标量相加。

**在你这个 Yaw 阻尼结构里，它具体在"加什么"？**

结合你前面的红框结构，这个 `Add2` 的两个输入是：
- **常数 1**
- **经绝对值和放大的纵向相对速度项 $10 \cdot |u|$**

所以这个模块实现的就是你前面写的那一项：

$$f(u) = 1 + 10|u|$$

📌 这一步只是在构造"速度相关放大因子"，不涉及力矩、不涉及 $r$。

#### 7.2 Selector 两个输入端口都选 index = 6，为什么只输出一个？另一个什么时候起作用？

**Selector 的基本规则（重点）**

**Selector 永远只输出一个信号。**
- ❌ 它不是 MUX
- ❌ 不是 Switch
- ❌ 不是 Merge

> Selector = 从输入信号里"摘取"指定索引的元素

**"输入端口数 = 2"到底是什么意思？**

你这个 Selector 的配置是：
- 输入端口数：2
- 索引方式：索引向量（对话框）
- 对两个输入端口，索引选项都设为 6

这在语义上等价于：

> "我有两个输入信号，每个都是一个向量；
> 我对这两个向量，都取它们的第 6 个分量；
> 然后把这两个取出来的'标量'，再组成一个向量输出。"

也就是说，输出不是"一个 6 号元素"，而是：

$$y = \begin{bmatrix} u_1(6) \\ u_2(6) \end{bmatrix}$$

⚠️ 这一点非常关键。

**为什么"看起来只用了一个 6 号"？**

因为你后面通常会：
- 直接接到单输入的运算块（例如 Product、Abs）
- 或者其中一个输入端口实际上接的是同一根信号
- 或者你后面只用了其中一个维度

在这些情况下，第二个端口"存在但没有被实际利用"，所以你感觉不到它。

**"另一个输入端口"什么时候真的会起作用？**

**✅ 情况 1：你后面把 Selector 输出当作"向量"来用**

例如：
- 输出是 $[r_1; r_2]$
- 后面做矩阵乘、范数、或再 Selector
- 这时两个端口都会同时生效

**✅ 情况 2：两个输入端口接的是"不同的信号源"**

比如：
- 输入 1：Relative Velocity（船体相对速度）
- 输入 2：State（6DOF 状态向量）

那么 Selector 输出的就是：

$$\begin{bmatrix} (\nu_r)_6 \\ (\nu)_6 \end{bmatrix}$$

你就能在同一个模块里并行比较 / 组合两个 yaw rate。

**❌ 情况 3（你现在的情况）：两个端口接的是"同一类信号"**

这时：
- 两个 index=6 得到的是同一个物理量
- 输出要么是两个一样的值
- 要么后面只用其中一个

➡️ 功能上就是**冗余设计**

**为什么工程里有人会这么"冗余地"用 Selector？**

这是一个**工程习惯问题**，不是 bug：
- 方便以后扩展（例如对比 body rate / relative rate）
- 从统一模板拷贝过来
- 预留接口（但没删干净）

在你这种"深度理解模型"的阶段，这种冗余反而会干扰你判断。

---

## 8. Selector 输出维度的验证

### 提问

<div align="center">

![Selector Dimension](https://cdn.nlark.com/yuque/0/2025/png/2408029/1766109257396-3044372f-ca40-43fc-a4a7-ca41ab3b0a2e.png)

</div>

稍等一下，假如6号索引的元素就是 $I_{zz}$，那这个红框里的模块的输出是一个 $[I_{zz}, I_{zz}]$ 矩阵对么？那 $N_r$ 那条信号线上的值不也是一个矩阵么？

我使用数据查看器，红框里的就是我的Selector4，但是看起来是一维的？

### 回答

**结论先给你：**

在 Simulink Data Inspector 里，你现在看到的 `Selector4:1` 是"一维标量"，这说明：**在当前这次仿真中，`Selector4` 的输出确实是 `1×1`，而不是 `2×1` 向量。**

也就是说：
- ❌ 并不存在一个"悄悄的 $[I_{zz}; I_{zz}]$ 向量"在这条线上流动
- ✅ Simulink 在当前配置下，实际上只输出了一个标量

这点以 Data Inspector 为准，它是"事实"。

#### 8.1 为什么理论上可能是 2×1，但你现在看到却是 1×1？

关键在于：**Selector 的"输入端口数 = 2"，并不等价于"输出一定是 2 维"**，还要看**每个输入端口实际接了什么、以及后续模块是否"压缩了维度"**。

**Selector 在 Simulink 里的真实规则（核心）**

1. Selector **对每一个输入端口**：按你设定的索引规则，**取出对应元素**
2. 然后：**把每个输入端口的"选取结果"按列拼接**

👉 前提是：这些输入端口的信号在运行时都是"独立有效的向量"

**但你现在这个模型里，很可能发生了下面之一（非常常见）**

**✅ 情况 A（最可能）：**

Selector 的两个输入端口，实际上接的是"同一根信号线的分支"，且 Simulink 在编译期把它们"合并优化"了。在这种情况下，Simulink 会把 Selector 退化为：对一个输入取一次索引，输出自然就是 1×1。

这在 **库模型 / 示例模型 / 为扩展预留端口** 的结构里非常常见。

**✅ 情况 B：**

Selector 的第二个输入端口在运行时是"空的 / 未参与计算的"。例如：
- 端口接了信号，但后续路径被裁剪
- 或被条件编译（variant / enabled subsystem）屏蔽

👉 那么只有第一个端口的 index=6 生效

**❌ 情况 C（你之前担心的）：**

两个输入端口都独立、都参与、都输出 index=6 ➡️ **这种情况 Data Inspector 一定会显示成 2 通道**

而你现在没看到，所以可以排除。

#### 8.2 为什么 Data Inspector 里"看起来是一条线"，就能说明它是标量？

这是一个**非常可靠的判断方法**：

如果信号是向量（哪怕是 2×1）：
- Data Inspector 会显示：`Selector4:1(1)` 和 `Selector4:1(2)`
- 或者允许你展开通道

你现在看到的是：
- 只有一条曲线
- 没有子通道

👉 这等价于：**信号维度 = 1**

#### 8.3 这件事对你当前问题意味着什么？

**好消息：**
- 你并没有被"隐式向量维度"坑
- $N_r$ 这条链路，在数值维度上是干净的
- "原地转"的问题**不来自"2×1 向量误用"**

**真正的问题，回到了我们更早就锁定的那一点：**

现在可以更确定地说：**偏航阻尼"过大"的问题，是"数值模型/物理建模层面的问题"**，而不是 Simulink 维度/语法层面的问题。

也就是说，重点还是在：

$$N_r = \frac{I_{zz}}{T_{yaw}} (1 + 10|u|)$$

这个结构**在物理意义上是否适合你当前的无人船**。

#### 8.4 工程建议

**🔧 建议 1（强烈）**

如果你这里的物理意义是：**$N_r$ 就是一个标量偏航阻尼系数**

那你应该：
1. 把这个 Selector 的输入端口数改成 1
2. 只保留：输入为 Inertials，index = 6
3. 确保 $N_r$ 这根线是 1×1 标量

这会：
- 消除隐式维度问题
- 消除"模板遗留逻辑"
- 让你后面所有物理判断都变得干净

**🔬 建议 2：验证实验**

既然我们已经确认：
- Selector4:1 是标量
- 模型维度是"干净的"

建议你做一个小实验：

1. **把 $(1 + 10|u|)$ 整个因子临时改成 1**，也就是：
   $$N_r = \frac{I_{zz}}{T_{yaw}}$$
2. 不改任何别的参数
3. 再跑一次你"差速转圈"的工况

**你将看到两种非常清晰的结果之一：**

- ✅ 如果轨迹立刻从"原地转"变成"能画出圆"：
  👉 **说明速度相关放大项确实过强**
- ❌ 如果几乎没变化：
  👉 那就该去看**推进器力矩 / surge–yaw 耦合 / Coriolis 项**

---

## 9. $T_{yaw}$ 的取值选择

### 提问

$T_{yaw}$ 的取值是怎么选取的？

### 回答

这是一个**非常关键、而且已经从"调参"进入"建模原则"的问题**。

#### 9.1 一句话结论

$T_{\text{yaw}}$ 不是"物理常数"，而是：**你希望"偏航角速度 $r$ 在没有外力矩时，衰减到 0 的时间尺度"。**

它的本质是一个**偏航一阶时间常数 / 阻尼时间尺度**。

#### 9.2 把你现在的模型"反写成一个最简单的方程"

你当前的 yaw 阻尼核心形式是：

$$N_{\text{damp}} = - N_r \cdot r, \quad N_r = \frac{I_{zz}}{T_{\text{yaw}}}$$

把它代入偏航动力学（忽略其他耦合，做最简化）：

$$I_{zz} \dot{r} = -\frac{I_{zz}}{T_{\text{yaw}}} r$$

两边同时除以 $I_{zz}$：

$$\dot{r} = -\frac{1}{T_{\text{yaw}}} r$$

👉 这一步非常关键，它说明：**$T_{\text{yaw}}$ 就是 yaw rate 的一阶衰减时间常数**

#### 9.3 物理解释

解这个微分方程：

$$r(t) = r(0) \cdot e^{-t/T_{\text{yaw}}}$$

也就是说：

| 时间 | 衰减程度 |
|------|----------|
| $t = T_{\text{yaw}}$ | $r$ 衰减到原来的 36.8% |
| $t \approx 3T_{\text{yaw}}$ | 基本"衰减干净" |

📌 所以你选 $T_{\text{yaw}}$，其实是在回答这个问题：

> "如果我松开推进器，船转起来了，它要多久才'自己停下来'？"

#### 9.4 工程上怎么选 $T_{\text{yaw}}$？（可直接用的区间）

**1️⃣ 如果你希望"真实 + 灵敏"（接近你的直觉）**

偏航容易发生，转起来不那么容易被压死。

推荐：

$$\boxed{T_{\text{yaw}} = 5 \sim 15\ \text{s}}$$

特性：
- 转弯半径自然
- 差速一给就会明显偏航
- 不会"原地转刹死"

👉 **这是最推荐你现在用的区间**

**2️⃣ 如果你希望"偏稳一点"（教学 / 演示 / 初期调试）**

不容易甩、轨迹好看。

常见：

$$T_{\text{yaw}} = 2 \sim 5\ \text{s}$$

特性：
- 偏航被明显抑制
- 转弯半径偏大
- 更像"被电子稳定系统照顾的船"

**3️⃣ 如果你现在用的是这个区间（⚠️ 很可能是问题源头）**

$$T_{\text{yaw}} < 1\ \text{s}$$

那么结论几乎可以肯定：
- ❌ 偏航阻尼一定过大
- ❌ 非常容易出现你现在看到的"差速 → 原地转 / 前进被压死"

#### 9.5 "反向思考法"来选 $T_{\text{yaw}}$

你可以不用一开始就猜数值，而是问自己一个**非常直观的问题**：

> "如果我现在以某个角速度在转弯，完全不给推进器，我希望船在多少秒内'基本不转了'？"

然后用这个规则：

| 期望行为 | 推荐 $T_{\text{yaw}}$ |
|----------|----------------------|
| 想 10 秒左右停下来 | $T_{\text{yaw}} \approx 3$ s |
| 想 20~30 秒慢慢停 | $T_{\text{yaw}} \approx 8 \sim 10$ s |
| 想几乎像没阻尼一样 | $T_{\text{yaw}} \ge 15$ s |

#### 9.6 结合你当前"差速转圈问题"的建议

你现在的症状是：
> "一差速，偏航立刻被放大/抑制得不自然，轨迹塌缩"

在这种情况下，强烈建议你按这个顺序做：

**✅ 第一步（定位）**

暂时去掉 $(1 + 10|u|)$，只保留：

$$N_r = \frac{I_{zz}}{T_{\text{yaw}}}$$

**✅ 第二步（选一个"不会错"的值）**

直接设：

$$\boxed{T_{\text{yaw}} = 8\ \text{s}}$$

这是一个：
- 不激进
- 不过稳
- 极少导致"原地转"的安全值

**✅ 第三步（再看轨迹）**

- 如果能画出自然的圆 → 说明你之前的问题**就是 yaw 阻尼过强**
- 再根据你想要的"灵敏程度"微调到 5 或 12

#### 9.7 非常重要的"建模原则"

> **不要让"你希望船稳一点"的愿望，通过一个速度放大因子偷偷写进动力学。**

稳定性应该来自：
- 合理的惯量
- 合理的推进器布局
- 合理的控制器

而不是：
- $N_r \propto |u|$ 这种"隐形电子稳定系统"

---


